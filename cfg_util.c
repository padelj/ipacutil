/*************************************************************************
 * TLV 02/15/2002                                                        *
 *                                                                       *
 * Ok, I'm not going to claim that this is pretty, but it should work    *
 * to parse fairly error free configuration files.  Since I plan to have *
 * the config files generated by a GUI program at some point, this is    *
 * probably ok.                                                          *
 *                                                                       *
 * Should you care to clean anything up and/or add better error checking *
 * and handling, feel free!                                              *
 *                                                                       *
 * Routines for reading from config files                                *
 *                                                                       *
 *                                                                       *
 * This is free software; you can redistribute it and/or modify          *
 * it under the terms of the GNU General Public License as published by  *
 * the Free Software Foundation; either version 2 of the License, or     *
 * at your option) any later version.                                    *
 *                                                                       *
 * This program is distributed in the hope that it will be useful,       *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 * GNU General Public License for more details.                          *
 *                                                                       *
 * You should have received a copy of the GNU General Public License     *
 * along with Foobar; if not, write to:                                  *
 *                   Free Software Foundation, Inc.                      *
 *                   59 Temple Place                                     *
 *                   Suite 330                                           *
 *                   Boston, MA  02111-1307                              *
 *                   USA                                                 *
 *************************************************************************/

#include "cfg_util.h"
#include <string.h>

/************************************************************************
 * Attempt to convert a string containing a hex value to an int         *
 *                                                                      *
 * Valid formats are: 0xyy or yy                                        *
 *  where y can be any of (0-9 and (a-f or A-F))                        *
 *                                                                      *
 *                                                                      *
 * Returns: returns int value on success, else -1                       *
 ************************************************************************/
int htoi(char *hexstr) {
  
   int tempval=0;
   int this_digit =0;
   int pos;

   pos = strlen(hexstr) - 1;

   while (pos >= 0) {
      switch (toupper(*hexstr)) {
      case 'X':
         /*This is the x from 0x - ignore it*/
      case '0':
         /*0 - don't have to do anything*/
	 this_digit = 0;
	 break;
      case '1':
	 this_digit = 1;
	 break;
      case '2':
	 this_digit = 2;
	 break;
      case '3':
	 this_digit = 3;
	 break;
      case '4':
	 this_digit = 4;
	 break;
      case '5':
	 this_digit = 5;
	 break;
      case '6':
	 this_digit = 6;
	 break;
      case '7':
	 this_digit = 7;
	 break;
      case '8':
	 this_digit = 8;
	 break;
      case '9':
	 this_digit = 9;
	 break;
      case 'A':
	 this_digit = 10;
	 break;
      case 'B':
	 this_digit = 11;
	 break;
      case 'C':
	 this_digit = 12;
	 break;
      case 'D':
	 this_digit = 13;
	 break;
      case 'E':
	 this_digit = 14;
	 break;
      case 'F':
	 this_digit = 15;
	 break;
      default:
         return -1;
      }
      if (this_digit) {
         tempval = tempval + (pow(16, pos) * this_digit);
      }
      hexstr++;
      pos--;
   }
   return tempval;
}

/************************************************************************
 * Attempt to read shift code and 96 key codes from config file         *
 *                                                                      *
 * Returns: 0 if read successfully, else -1                             *
 ************************************************************************/
int ReadCfg(cmdline_opt_s *settings, char *cfg_data) {

   FILE *stream;
   char buf[255];
   char temp_code[255];
   char temp_label[255];
   char comment[255];
   int temp_num;
   int i, curpass, passes;
   int unshifted_len = -1;
   int shifted_len = -1;
   int board_type = -1;
   char *data_ptr;
   char *unshifted_str;
   char *shifted_str;
   char *macro_str;
   char *cfg_file;

   cfg_file = settings->config_file;

   if ((stream = fopen(cfg_file, "r")) == NULL) {
      perror("Failed to open config file");
      return -1;
   }

   cfg_data[SHIFT_CODE_OFFSET] = -1;  

   /*Now, try to find the Misc section*/
   if (GotoSection(stream, (char *)MISC_SECTION)) {
      /* Read until we find close section*/
      while (ReadNextLine(stream, buf)) {
         sscanf(buf,"%s\t%s\t%s\n", temp_label, temp_code, comment);
         temp_num = htoi(temp_code);
	     if (strcmp(temp_label, SHIFT_CODE_LABEL) == 0) {
	        cfg_data[SHIFT_CODE_OFFSET] = temp_num;   /*Shift code */
	     }
	     if (strcmp(temp_label, BOARD_TYPE_LABEL) == 0) {
	       board_type = temp_num;
           settings->board_type = board_type;
         }
      }
   } else {
      /*Failed to find the misc section*/
      printf("Malformed config file: Failed to find the misc section.\n");
      return -1;
   }


   if (cfg_data[SHIFT_CODE_OFFSET] < 0) {
      printf("Malformed config file: Failed to find shift code.\n");
      return -1;
   }

   if (board_type < 0) {
      printf("Board type (%s in %s section) not specified\n", BOARD_TYPE_LABEL, MISC_SECTION);
      return -1;
   }
   //printf("Read cfg: board type: %s\n", board_name_by_type[board_type]);
   
   if (board_type == BOARD_TYPE_IPAC4_56) {
       cfg_data[SHIFT_CODE_OFFSET + IPAC_DATA_LEN] = cfg_data[SHIFT_CODE_OFFSET];   /*Shift code */
   }

   unshifted_len = board_info[board_type][BOARD_INFO_INDEX_UNSHIFTED_CODES];
   shifted_len   = board_info[board_type][BOARD_INFO_INDEX_SHIFTED_CODES];
   passes        = board_info[board_type][BOARD_INFO_INDEX_PASSES];
  

for(curpass=0; curpass<passes; curpass++) {
   if (curpass==0) {
      unshifted_str = (char *)UNSHIFTED_SECTION;
      shifted_str   = (char *)SHIFTED_SECTION;
      macro_str     = (char *)MACRO_SECTION;
      data_ptr = cfg_data;
   } else {
      unshifted_str = (char *)UNSHIFTED_SECTION2;
      shifted_str   = (char *)SHIFTED_SECTION2;
      macro_str     = (char *)MACRO_SECTION2;
      data_ptr = &cfg_data[IPAC_DATA_LEN];
   }

   /* start at 1 to leave room for the shift code */
   i=1;
   /*Next, try to find the unshifted section*/
   if (GotoSection(stream, unshifted_str)) {
      while (ReadNextLine(stream, buf)) {
         if (i >= IPAC_DATA_LEN - 3) {  /* -3 to account for shift, control, checksum */
            printf("Malformed config file: too many keycodes found %d (unshifted)\n", i);
            return -1;
         }
         sscanf(buf,"%s\t0x%s\t%s\n", temp_label, temp_code, comment);
	 temp_num = htoi(temp_code);
	 data_ptr[i] = temp_num;
	 i++;
      }
   } else {
      /*Failed to find the unshifted section*/
      printf("Malformed config file: Failed to find the unshifted section.\n");
      return -1;
   }

   /*Now, try to find the shifted section*/
   if (GotoSection(stream, shifted_str)) {
      while (ReadNextLine(stream, buf)) {
         if (i >= IPAC_DATA_LEN - 3) {  /* -3 to account for shift, control, checksum */
            printf("Malformed config file: too many keycodes found %d (shifted)\n", i);
            return -1;
         }
         sscanf(buf,"%s\t0x%s\t%s\n", temp_label, temp_code, comment);
	 temp_num = htoi(temp_code);
	 data_ptr[i] = temp_num;
	 i++;
      }
   } else {
      /*Failed to find the shifted section*/
      printf("Malformed config file: Failed to find the shifted section.\n");
      return -1;
   }

   /* Leave room for the checksum and control bytes */
   i+=2;

   /* Try to read the macro section */
   if (GotoSection(stream, macro_str)) {
      while (ReadNextLine(stream, buf)) {
         if (i >= IPAC_DATA_LEN - 3) {  /* -3 to account for shift, control, checksum */
            printf("Malformed config file: too many keycodes found %d (shifted)\n", i);
            return -1;
         }
         sscanf(buf,"%s\t0x%s\t%s\n", temp_label, temp_code, comment);
	 temp_num = htoi(temp_code);
//printf("Found macro: %s\tcode:0x%x\n", temp_label, temp_num);
	 data_ptr[i] = temp_num;
	 i++;
      }	   
   } else {
      /*Failed to find the shifted section*/
      printf("Malformed config file: Failed to find the shifted section.\n");
      return -1;
   }


   /* Finally, pad out with 0s */
   for (;i < IPAC_DATA_LEN - 1; i++) {
      data_ptr[i] = 0;
   }
} //for passes


   fclose(stream);

   /*Normal completion*/
   return 0;
}

/************************************************************************
 * Try to find a section in a config file.  Moves pointer to that point *
 *                                                                      *
 * Returns: 1 if found, else 0                                          *
 ************************************************************************/
int GotoSection(FILE *stream, char *section) {

   char buf[255];
   int i=0;
   int no_seek=0;
   char tempname[255];

   /*Check if we're already at the beginning of the file...*/
   if (ftell(stream) == 0) 
      no_seek = 1;

   /*Look for the section heading*/
   /*Headings look like: [SectionName]*/
   while (!feof(stream)) {
      fgets(buf, 254, stream);
      /*Get rid of any garbage on the end of the string*/
      sscanf(buf, "%s", tempname);
      if (strcmp(tempname, section) == 0) {
         /*Yup, this is the section!*/
         return 1;
      }

      /*Didn't find it -- to verify, seek to the beginning and try again*/
      if ((i=0) && (feof(stream)) && (no_seek != 1)) {
         printf("Moving back to start of file\n");
         rewind(stream);
      }
   }

   /*Didn't find the specified section*/
   return 0;

}


/************************************************************************
 * Try to read the next line in a config file.  Automatically skips     *
 * over comments.                                                       *
 *                                                                      *
 * Returns: 1 if valid, else 0                                          *
 ************************************************************************/
int ReadNextLine(FILE *stream, char *buf_line) {
   char tempbuf[255];
   int done=0;

   while ((!feof(stream)) && (!done)) {
      if (fgets(tempbuf, 254, stream) != NULL) {
         switch (tempbuf[0]) {
	 case '#':
            /*This is a comment line -- skip it*/
	    break;
         case '.':
	    /*Reached end of section -- we can't read any further*/
	    done=1;
	    break;
	 default:
	    /*Found a valid line*/
	    strcpy(buf_line, tempbuf);
	    return 1;
         }
      } else {
         perror("Error reading next line\n");
	 return 0;
      }
   }
   return 0;
}

/************************************************************************
 * Try to generate a default configuration file using the default MAME  *
 * settings.                                                            *
 *                                                                      *
 * Returns: 0 if written ok, else -1                                    *
 ************************************************************************/
int WriteDefaultCfg(char *filename, int board_type) {

   struct key_struct data_def[IPAC_DATA_LEN * 2]; /* 2x as long to cover IPAC-4 */
   int i, pass;
   int valid_len = board_info[board_type][BOARD_INFO_INDEX_SHIFTED_CODES] +
                   board_info[board_type][BOARD_INFO_INDEX_UNSHIFTED_CODES];
   const struct key_struct *src_data;
   struct key_struct *data_ptr;
  
   for(pass=0; pass<board_info[board_type][BOARD_INFO_INDEX_PASSES]; pass++) {

      if (pass == 0) {
         data_ptr = data_def;
      } else {
         data_ptr = &data_def[IPAC_DATA_LEN];
      }

      switch (board_type) {
         case BOARD_TYPE_IPAC2_28:
            src_data = ipac2_defaults;
            break;
         case BOARD_TYPE_IPAC4_56:
            if (pass==0) {
               src_data = ipac2_defaults;
            } else {
               src_data = ipac4_defaults;
            }
            break;
         case BOARD_TYPE_IPACVE:
         case BOARD_TYPE_IPAC2_32:
            src_data = ipacve_defaults;
            break;
         case BOARD_TYPE_MINIPACVE:
            src_data = minipacve_defaults;
            break;
         default:
           return -1;
      }

      for(i=0; i<IPAC_DATA_LEN; i++) {
          if (i<valid_len) {
             data_ptr[i] = src_data[i];
          } else {
             // TODO: probably don't need to bother zeroing everything
             data_ptr[i].def_code = 0x00;
             data_ptr[i].comment  = "";
             data_ptr[i].def_key  = "";
          }
      }
   }


   return WriteCfgFile(filename, data_def, DEF_SHIFT, macro_defaults, board_type);

}

/************************************************************************
 * Try to generate a configuration file                                 *
 *                                                                      *
 * Returns: 0 if written ok, else -1                                    *
 ************************************************************************/
int WriteCfgFile(char *filename, struct key_struct *data_def, 
                 struct key_struct shift_def, struct key_struct *macro_def,
		 int board_type) {

   FILE *stream;
   int i, pass;
   int unshifted_len = board_info[board_type][BOARD_INFO_INDEX_UNSHIFTED_CODES];
   int shifted_len   = board_info[board_type][BOARD_INFO_INDEX_SHIFTED_CODES];
   struct key_struct *data_ptr;
   char *shifted_str, *unshifted_str, *macro_str;

   if ((stream = fopen(filename, "w")) == NULL) {
      printf("Failed to open %s for writing\n", filename);
      return -1;
   }

   /*Write out the misc section*/
   fprintf(stream, "%s\n", MISC_SECTION);
   fprintf(stream, "%s\t0x%02X\t;%s - %s\n", SHIFT_CODE_LABEL, 
           shift_def.def_code, shift_def.comment, shift_def.def_key);
   fprintf(stream, "%s\t0x%02X\t;%s - %s\n", BOARD_TYPE_LABEL, 
           board_type, "board type", board_name_by_type[board_type]);
   fprintf(stream, "%s\n\n", SECTION_CLOSE);

   for(pass=0; pass < board_info[board_type][BOARD_INFO_INDEX_PASSES]; pass++) {
       if (pass==0) {
          data_ptr = data_def;
	  unshifted_str = (char *)UNSHIFTED_SECTION;
	  shifted_str   = (char *)SHIFTED_SECTION;
	  macro_str     = (char *)MACRO_SECTION;
       } else {
          data_ptr = data_def + IPAC_DATA_LEN;
	  unshifted_str = (char *)UNSHIFTED_SECTION2;
	  shifted_str   = (char *)SHIFTED_SECTION2;
	  macro_str     = (char *)MACRO_SECTION2;
       }

       /*Write out the unshifted section*/
       fprintf(stream, "%s\n", unshifted_str);
       for(i=0; i< unshifted_len; i++) {
          fprintf(stream, "%d\t0x%02X\t;%s - %s\n", i, data_ptr[i].def_code,
                  data_ptr[i].comment, data_ptr[i].def_key);
       }
       fprintf(stream, "%s\n\n", SECTION_CLOSE);

       /*Write out the shifted section*/
       fprintf(stream, "%s\n", shifted_str);
       for(; i < shifted_len + unshifted_len; i++) {
           fprintf(stream, "%d\t0x%02X\t;%s - %s\n", (i - unshifted_len), data_ptr[i].def_code,
                  data_ptr[i].comment, data_ptr[i].def_key);
       }
       fprintf(stream, "%s\n\n", SECTION_CLOSE);

       /*Write out the macro section*/
       fprintf(stream, "%s\n", macro_str);
       for(i=0; i<NUM_MACRO_KEYCODES; i++) {
           fprintf(stream, "%d\t0x%02X\t;%s - %s\n", i, macro_def[i].def_code,
                  macro_def[i].comment, macro_def[i].def_key);
       }
       fprintf(stream, "%s\n\n", SECTION_CLOSE);
   }
   
   fflush(stream);
   fclose(stream);

   /*Normal completion*/
   return 0;
}


